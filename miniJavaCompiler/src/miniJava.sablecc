Package minijava;

Helpers
	tab          		= 9;
	lf           		= 10;
	cr           		= 13;
	decimal        		= ['0' .. '9'];
	character     		= [['a' .. 'z'] + ['A' .. 'Z']];
	anychar      		= [0x0 .. 0xfff];
	line_terminator 	= cr lf | cr | lf;
	white_space_aux    	= tab | ' ';
	without_star    	= [anychar - '*'];
	without_star_slash  = [without_star - '/'];
	linecomment  		= '//' [anychar - [cr + lf]]* line_terminator?;
    blockcomment_aux	= '/*' without_star* '*'+ (without_star_slash without_star* '*'+)* '/';

Tokens
	// Identificadores
	intv    = 'int' white_space_aux* '[' white_space_aux* ']';
    tok_int     = 'int';
    tok_boolean = 'boolean';
    tok_class = 'class';
    tok_public  = 'public';
    tok_extends = 'extends';
    tok_if      = 'if';
    tok_while   = 'while';
    tok_else    = 'else';
    tok_return  = 'return';
    tok_true    = 'true';
    tok_false   = 'false';
    tok_this    = 'this';
    tok_new     = 'new';
    tok_length  = 'length';
    tok_string  = 'String';
    tok_print   = 'System.out.println';
    tok_static  = 'static';
    tok_void    = 'void';
    tok_main    = 'main';
    tok_null    = 'null';

	// Simbolos
    l_brack = '[';
    r_brack = ']';
    l_paren = '(';
    r_paren = ')';
    l_brace = '{';
    r_brace = '}';
    dot    = '.';
    comma  = ',';
    semi   = ';';

    plus  = '+';
    minus = '-';
    times = '*';
    gt    = '>';
    lt    = '<';
    ge    = '>=';
    le    = '<=';
    and   = '&&';
    or    = '||';
    eq    = '==';
    neq   = '!=';
    not   = '!';
    be    = '=';

	// Outros
    id     = character (character | decimal | '_')*;
    number = '0' | ([decimal - '0'] decimal*);

	// Ignorados
    white_space   = (white_space_aux | line_terminator)+;
    block_comment = linecomment | blockcomment_aux;
   
Ignored Tokens
	white_space, block_comment;


Productions
    program { -> program }
        = main_class classdecl
            { -> New program(main_class, [classdecl.class_decl]) };

    main_class { -> main_class }
        = tok_class [name]:id [op]:l_brace tok_public tok_static tok_void tok_main l_paren tok_string l_brack r_brack [arg]:id r_paren [os]:l_brace statementlist [cp]:r_brace [cs]:r_brace
            { -> New main_class(name, arg, [statementlist.statement]) };

    classdecl { -> class_decl* }
        = {ext} tok_class [cname]:id tok_extends [ename]:id l_brace vardecl method_decl r_brace classdecl
            { -> [New class_decl.ext(cname, ename, [vardecl.var_decl], [method_decl.method_decl]), classdecl.class_decl] }
        | {nonext} tok_class id l_brace vardecl method_decl r_brace classdecl
            { -> [New class_decl.nonext(id, [vardecl.var_decl], [method_decl.method_decl]), classdecl.class_decl] }
        | {empty}
        	{ -> [] };
  
    vardecl { -> var_decl* }
        = {nonempty} vardecl type id semi
            { -> [vardecl.var_decl, New var_decl(type, id)] }
        | {empty}
        	{ -> [] };

    method_decl { -> method_decl* }
        = {nonempty} tok_public type id l_paren formallist r_paren l_brace vardecl statementlist tok_return expr semi r_brace method_decl
            { -> [New method_decl(type, id, [formallist.formal], [vardecl.var_decl], [statementlist.statement], expr.exp), method_decl.method_decl] }
        | {empty}
        	{ -> [] };

    formallist { -> formal* }
        = {nonempty} type id formalrest
            { -> [New formal(New var_decl(type, id), [formalrest.formal])] }
        | {empty}
        	{ -> [] };

    formalrest { -> formal* }
        = {remainder} comma type id formalrest
            { -> [New formal(New var_decl(type, id), [formalrest.formal])] }
        | {empty}
        	{ -> [] };
    
    statementlist { -> statement* }
    	= {nonempty} statement statementlist
    		{ -> [statement, statementlist.statement] }
    	| {empty}
    		{ -> [] };

    statement { -> statement }
		= {open} statement1
			{ -> statement1.statement }
		| {closed} statement2
			{ -> statement2.statement };

    statement1 { -> statement }
        = {if}  tok_if l_paren expr r_paren statement
            { -> New statement.if(expr.exp, statement, []) }
        | {ifelse}  tok_if l_paren expr r_paren [i]:statement2 tok_else [e]:statement1
            { -> New statement.if(expr.exp, i.statement, [e.statement]) }
        | {while}   tok_while l_paren expr r_paren statement1
            { -> New statement.while(expr.exp, statement1.statement) };
            
    statement2 { -> statement }
        = {nested}  l_brace statementlist r_brace
            { -> New statement.block([statementlist.statement]) }
        | {ifelse}  tok_if l_paren expr r_paren [i]:statement2 tok_else [e]:statement2
            { -> New statement.if(expr.exp, i.statement, [e.statement]) }
        | {while}   tok_while l_paren expr r_paren statement2
            { -> New statement.while(expr.exp, statement2.statement) }
        | {print}   tok_print l_paren expr r_paren semi
            { -> New statement.print(expr.exp) }
        | {assign}  id be expr semi
            { -> New statement.assign(id, expr.exp) }
        | {vassign} id l_brack [i]:expr r_brack be [v]:expr semi
            { -> New statement.array_assign(id, i.exp, v.exp) };
		            
    type
        = {intt}  tok_int
			{ -> New type.int(tok_int) }
        | {intv}  intv
			{ -> New type.array(intv) }
        | {bool}  tok_boolean
			{ -> New type.boolean(tok_boolean) }
        | {class} id
			{ -> New type.class(id) };

	noarrayexpr { -> exp }
        = {name}    id
        	{ -> New exp.identifier(id) }
		| {literal} number
            { -> New exp.integer_literal(number) }
        | {true}    tok_true
            { -> New exp.true(tok_true) }
        | {false}   tok_false
            { -> New exp.false(tok_false) }
        | {this}    tok_this
            { -> New exp.this(tok_this) }
		| {parexp}  l_paren expr r_paren
        	{ -> expr.exp }
        | {vaccess} noarrayexpr l_brack expr r_brack 
            { -> New exp.array_lookup(noarrayexpr.exp, expr.exp) }
        | {length}  primaryexpr dot tok_length
            { -> New exp.array_length(primaryexpr.exp) }
        | {maccess} primaryexpr dot id l_paren exprlist r_paren
            { -> New exp.call(primaryexpr.exp, id, [exprlist.exp]) }
        | {newc} tok_new id l_paren r_paren
            { -> New exp.new_object(id) };

	primaryexpr { -> exp }
		= {newarr} tok_new tok_int l_brack expr r_brack matrixaccess
            { -> New exp.new_array(expr.exp, [matrixaccess.exp]) }
		| {next}   noarrayexpr
			{ -> noarrayexpr.exp };
			
	matrixaccess { -> exp* }
		= {nonempty} l_brack expr r_brack matrixaccess
			{ -> [expr.exp, matrixaccess.exp] }
		| {empty}
        	{ -> [] }; 
        	
	unaryexpr { -> exp }
    	= {not}  not unaryexpr
    		{ -> New exp.not(unaryexpr.exp) }
    	| {next} primaryexpr
    		{ -> primaryexpr.exp };
    		
    ipexpr { -> exp }
        = {times} ipexpr times unaryexpr
            { -> New exp.times(ipexpr.exp, unaryexpr.exp) }
        | {next} unaryexpr
            { -> unaryexpr.exp };

    iaexpr { -> exp }
        = {plus}  iaexpr plus ipexpr
            { -> New exp.plus(iaexpr.exp, ipexpr.exp) }
        | {minus} iaexpr minus ipexpr
            { -> New exp.minus(iaexpr.exp, ipexpr.exp) }
        | {next}  ipexpr
            { -> ipexpr.exp };

    bexpr { -> exp }
        = {greater} bexpr gt iaexpr
            { -> New exp.gthan(bexpr.exp, iaexpr.exp) }
        | {ge} bexpr ge iaexpr
            { -> New exp.ge(bexpr.exp, iaexpr.exp) }
        | {less}    bexpr lt iaexpr
            { -> New exp.lthan(bexpr.exp, iaexpr.exp) }
        | {le}    bexpr le iaexpr
            { -> New exp.less_than(bexpr.exp, iaexpr.exp) }
        | {next}    iaexpr
            { -> iaexpr.exp };

    expr { -> exp }
        = {and}  expr and bexpr
            { -> New exp.and(expr.exp, bexpr.exp) }
        | {or}   expr or bexpr
            { -> New exp.or(expr.exp, bexpr.exp) }
        | {logicalequal} expr eq bexpr
            { -> New exp.equal(expr.exp, bexpr.exp) }
        | {noteq} expr neq bexpr
            { -> New exp.noteq(expr.exp, bexpr.exp) }
        | {next} bexpr
            { -> bexpr.exp };

    exprlist { -> exp* }
        = {nonempty} expr exprrest
            { -> [expr.exp, exprrest.exp] }
        | {empty}
        	{ -> [] };

    exprrest { -> exp* }
        = {remainder} comma expr exprrest
            { -> [expr.exp, exprrest.exp] }
        | {empty}
        	{ -> [] };


Abstract Syntax Tree
    program
        = main_class class_decl*;

    main_class
        = [cn]:id [an]:id statement*;

    class_decl
        = {ext}    [name]:id [ext]:id var_decl* method_decl*
        | {nonext} id var_decl* method_decl*;

    formal
       = var_decl formal*;

    var_decl
       = type id;

    method_decl
        = type id formal* var_decl* statement* exp;

    statement
        = {if}    exp [i]:statement [e]:statement*
        | {array_assign}  id [i]:exp [v]:exp
        | {assign}   id exp
        | {while} exp statement
        | {print} exp
        | {block}  statement*;

    exp
        = {call}  [obj]:exp id [par]:exp*
        | {plus}   [l]:exp [r]:exp
        | {minus}  [l]:exp [r]:exp
        | {times}   [l]:exp [r]:exp
        | {and}    [l]:exp [r]:exp
        | {or}     [l]:exp [r]:exp
        | {gthan}  [l]:exp [r]:exp
        | {ge}     [l]:exp [r]:exp
        | {lthan}  [l]:exp [r]:exp
        | {less_than}     [l]:exp [r]:exp
        | {equal}   [l]:exp [r]:exp
        | {noteq}  [l]:exp [r]:exp
        | {array_lookup} [l]:exp [e]:exp
        | {array_length} exp
        | {not}    exp
        | {new_array} [l]:exp [i]:exp*
        | {identifier}    id
        | {new_object} id
        | {integer_literal} number
        | {true}  tok_true
        | {false} tok_false
        | {this}   tok_this;
    
    type
        = {int}  tok_int
        | {array}  intv
        | {boolean}  tok_boolean
        | {class} id
        | {object} id;
