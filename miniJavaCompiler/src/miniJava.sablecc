Package minijava;

Helpers
	tab          		= 9;
	lf           		= 10;
	cr           		= 13;
	decimal        		= ['0' .. '9'];
	character     		= [['a' .. 'z'] + ['A' .. 'Z']];
	anychar      		= [0x0 .. 0xfff];
	line_terminator 	= cr lf | cr | lf;
	white_space_aux    	= tab | ' ';
	without_star    	= [anychar - '*'];
	without_star_slash  = [without_star - '/'];
	linecomment  		= '//' [anychar - [cr + lf]]* line_terminator?;
    blockcomment_aux	= '/*' without_star* '*'+ (without_star_slash without_star* '*'+)* '/';

Tokens
	// Identificadores
	intv    = 'int' white_space_aux* '[' white_space_aux* ']';
    tok_int     = 'int';
    tok_boolean = 'boolean';
    tok_class = 'class';
    tok_public  = 'public';
    tok_extends = 'extends';
    tok_if      = 'if';
    tok_while   = 'while';
    tok_else    = 'else';
    tok_return  = 'return';
    tok_true    = 'true';
    tok_false   = 'false';
    tok_this    = 'this';
    tok_new     = 'new';
    tok_length  = 'length';
    tok_string  = 'String';
    tok_print   = 'System.out.println';
    tok_static  = 'static';
    tok_void    = 'void';
    tok_main    = 'main';
    tok_null    = 'null';

	// Simbolos
    l_brack = '[';
    r_brack = ']';
    l_paren = '(';
    r_paren = ')';
    l_brace = '{';
    r_brace = '}';
    dot    = '.';
    comma  = ',';
    semi   = ';';

    plus  = '+';
    minus = '-';
    times = '*';
    gt    = '>';
    lt    = '<';
    ge    = '>=';
    le    = '<=';
    and   = '&&';
    or    = '||';
    eq    = '==';
    neq   = '!=';
    not   = '!';
    be    = '=';

	// Outros
    id     = character (character | decimal | '_')*;
    number = '0' | ([decimal - '0'] decimal*);

	// Ignorados
    white_space   = (white_space_aux | line_terminator)+;
    block_comment = linecomment | blockcomment_aux;
   
Ignored Tokens
	white_space, block_comment;


Productions
    program { -> program }
        = mainclass classdecl
            { -> New program(mainclass, [classdecl.nextclass]) };

    mainclass { -> mainclass }
        = tok_class [name]:id [op]:l_brace tok_public tok_static tok_void tok_main l_paren tok_string l_brack r_brack [arg]:id r_paren [os]:l_brace statementlist [cp]:r_brace [cs]:r_brace
            { -> New mainclass(name, arg, [statementlist.statement]) };

    classdecl { -> nextclass* }
        = {ext} tok_class [cname]:id tok_extends [ename]:id l_brace vardecl methoddecl r_brace classdecl
            { -> [New nextclass.ext(cname, ename, [vardecl.var], [methoddecl.method]), classdecl.nextclass] }
        | {nonext} tok_class id l_brace vardecl methoddecl r_brace classdecl
            { -> [New nextclass.nonext(id, [vardecl.var], [methoddecl.method]), classdecl.nextclass] }
        | {empty}
        	{ -> [] };
  
    vardecl { -> var* }
        = {nonempty} vardecl type id semi
            { -> [vardecl.var, New var(type, id)] }
        | {empty}
        	{ -> [] };

    methoddecl { -> method* }
        = {nonempty} tok_public type id l_paren formallist r_paren l_brace vardecl statementlist tok_return expr semi r_brace methoddecl
            { -> [New method(type, id, [formallist.var], [vardecl.var], [statementlist.statement], expr.expression), methoddecl.method] }
        | {empty}
        	{ -> [] };

    formallist { -> var* }
        = {nonempty} type id formalrest
            { -> [New var(type, id), formalrest.var] }
        | {empty}
        	{ -> [] };

    formalrest { -> var* }
        = {remainder} comma type id formalrest
            { -> [New var(type, id), formalrest.var] }
        | {empty}
        	{ -> [] };
    
    statementlist { -> statement* }
    	= {nonempty} statement statementlist
    		{ -> [statement, statementlist.statement] }
    	| {empty}
    		{ -> [] };

    statement { -> statement }
		= {open} statement1
			{ -> statement1.statement }
		| {closed} statement2
			{ -> statement2.statement };

    statement1 { -> statement }
        = {if}  tok_if l_paren expr r_paren statement
            { -> New statement.if(expr.expression, statement) }
        | {ifelse}  tok_if l_paren expr r_paren [i]:statement2 tok_else [e]:statement1
            { -> New statement.ifelse(expr.expression, i.statement, e.statement) }
        | {while}   tok_while l_paren expr r_paren statement1
            { -> New statement.while(expr.expression, statement1.statement) };
            
    statement2 { -> statement }
        = {nested}  l_brace statementlist r_brace
            { -> New statement.many([statementlist.statement]) }
        | {ifelse}  tok_if l_paren expr r_paren [i]:statement2 tok_else [e]:statement2
            { -> New statement.ifelse(expr.expression, i.statement, e.statement) }
        | {while}   tok_while l_paren expr r_paren statement2
            { -> New statement.while(expr.expression, statement2.statement) }
        | {print}   tok_print l_paren expr r_paren semi
            { -> New statement.print(expr.expression) }
        | {assign}  id be expr semi
            { -> New statement.atb(id, expr.expression) }
        | {vassign} id l_brack [i]:expr r_brack be [v]:expr semi
            { -> New statement.vatb(id, i.expression, v.expression) };
		            
    type
        = {intt}  tok_int
			{ -> New type.intt(tok_int) }
        | {intv}  intv
			{ -> New type.intv(intv) }
        | {bool}  tok_boolean
			{ -> New type.bool(tok_boolean) }
        | {class} id
			{ -> New type.class(id) };

	noarrayexpr { -> expression }
        = {name}    id
        	{ -> New expression.var(id) }
		| {literal} number
            { -> New expression.number(number) }
        | {true}    tok_true
            { -> New expression.btrue(tok_true) }
        | {false}   tok_false
            { -> New expression.bfalse(tok_false) }
        | {self}    tok_this
            { -> New expression.self(tok_this) }
		| {parexp}  l_paren expr r_paren
        	{ -> expr.expression }
        | {vaccess} noarrayexpr l_brack expr r_brack 
            { -> New expression.vector(noarrayexpr.expression, expr.expression) }
        | {length}  primaryexpr dot tok_length
            { -> New expression.length(primaryexpr.expression) }
        | {maccess} primaryexpr dot id l_paren exprlist r_paren
            { -> New expression.mcall(primaryexpr.expression, id, [exprlist.expression]) }
        | {newc} tok_new id l_paren r_paren
            { -> New expression.newobj(id) };

	primaryexpr { -> expression }
		= {newarr} tok_new tok_int l_brack expr r_brack matrixaccess
            { -> New expression.newvec(expr.expression, [matrixaccess.expression]) }
		| {next}   noarrayexpr
			{ -> noarrayexpr.expression };
			
	matrixaccess { -> expression* }
		= {nonempty} l_brack expr r_brack matrixaccess
			{ -> [expr.expression, matrixaccess.expression] }
		| {empty}
        	{ -> [] }; 
        	
	unaryexpr { -> expression }
    	= {not}  not unaryexpr
    		{ -> New expression.not(unaryexpr.expression) }
    	| {next} primaryexpr
    		{ -> primaryexpr.expression };
    		
    ipexpr { -> expression }
        = {mult} ipexpr times unaryexpr
            { -> New expression.mult(ipexpr.expression, unaryexpr.expression) }
        | {next} unaryexpr
            { -> unaryexpr.expression };

    iaexpr { -> expression }
        = {plus}  iaexpr plus ipexpr
            { -> New expression.plus(iaexpr.expression, ipexpr.expression) }
        | {minus} iaexpr minus ipexpr
            { -> New expression.minus(iaexpr.expression, ipexpr.expression) }
        | {next}  ipexpr
            { -> ipexpr.expression };

    bexpr { -> expression }
        = {greater} bexpr gt iaexpr
            { -> New expression.gthan(bexpr.expression, iaexpr.expression) }
        | {ge} bexpr ge iaexpr
            { -> New expression.ge(bexpr.expression, iaexpr.expression) }
        | {less}    bexpr lt iaexpr
            { -> New expression.lthan(bexpr.expression, iaexpr.expression) }
        | {le}    bexpr le iaexpr
            { -> New expression.le(bexpr.expression, iaexpr.expression) }
        | {next}    iaexpr
            { -> iaexpr.expression };

    expr { -> expression }
        = {and}  expr and bexpr
            { -> New expression.and(expr.expression, bexpr.expression) }
        | {or}   expr or bexpr
            { -> New expression.or(expr.expression, bexpr.expression) }
        | {logicalequal} expr eq bexpr
            { -> New expression.loeq(expr.expression, bexpr.expression) }
        | {noteq} expr neq bexpr
            { -> New expression.noteq(expr.expression, bexpr.expression) }
        | {next} bexpr
            { -> bexpr.expression };

    exprlist { -> expression* }
        = {nonempty} expr exprrest
            { -> [expr.expression, exprrest.expression] }
        | {empty}
        	{ -> [] };

    exprrest { -> expression* }
        = {remainder} comma expr exprrest
            { -> [expr.expression, exprrest.expression] }
        | {empty}
        	{ -> [] };


Abstract Syntax Tree
    program
        = mainclass nextclass*;

    mainclass
        = [cn]:id [an]:id statement*;

    nextclass
        = {ext}    [name]:id [ext]:id var* method*
        | {nonext} id var* method*;

    var
       = type id;

    method
        = type id [param]:var* [local]:var* statement* expression;

    statement
        = {ifelse}    expression [i]:statement [e]:statement
        | {if}    expression statement
        | {vatb}  id [i]:expression [v]:expression
        | {atb}   id expression
        | {while} expression statement
        | {print} expression
        | {many}  statement*;

    expression
        = {mcall}  [obj]:expression id [par]:expression*
        | {plus}   [l]:expression [r]:expression
        | {minus}  [l]:expression [r]:expression
        | {mult}   [l]:expression [r]:expression
        | {and}    [l]:expression [r]:expression
        | {or}     [l]:expression [r]:expression
        | {gthan}  [l]:expression [r]:expression
        | {ge}     [l]:expression [r]:expression
        | {lthan}  [l]:expression [r]:expression
        | {le}     [l]:expression [r]:expression
        | {loeq}   [l]:expression [r]:expression
        | {noteq}  [l]:expression [r]:expression
        | {vector} [l]:expression [e]:expression
        | {length} expression
        | {not}    expression
        | {newvec} [l]:expression [i]:expression*
        | {var}    id
        | {newobj} id
        | {number} number
        | {btrue}  tok_true
        | {bfalse} tok_false
        | {self}   tok_this;
    
    type
        = {intt}  tok_int
        | {intv}  intv
        | {bool}  tok_boolean
        | {class} id;
