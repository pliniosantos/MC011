Package minijava;

Helpers

  and = '&&'; 
  lthan = '<'; 
  plus ='+'; 
  minus = '-'; 
  times = '*';

  underscore = '_'; 
  lf = 10;
  cr = 13;
  tab = 9;
  line_terminator = lf | cr | cr lf;

  decimal = ['0'..'9'];
  less_char = ['a'..'z'];
  more_char = ['A'..'Z'];
  any_character = [0..0xffff];

States

normal, comentado;

Tokens

  {normal} classe = 'class';
  {normal} public = 'public'; 
  {normal} static = 'static'; 
  {normal} void = 'void'; 
  {normal} main = 'main'; 
  {normal} string = 'String'; 
  {normal} extends = 'extends'; 
  {normal} return = 'return'; 

  {normal} dot = '.';
  {normal} int = 'int'; 
  {normal} boolean = 'boolean'; 
  {normal} lcol = '['; 
  {normal} rcol = ']'; 
  {normal} lpar = '('; 
  {normal} rpar = ')'; 
  {normal} lbra = '{'; 
  {normal} rbra = '}'; 
  {normal} equal = '='; 
  {normal} semic = ';'; 
  {normal} comma = ',';
  {normal} not = '!'; 

  {normal} if = 'if'; 
  {normal} else = 'else'; 
  {normal} while = 'while'; 
  {normal} print = 'System.out.println'; 
  {normal} length = 'length'; 
  {normal} true = 'true'; 
  {normal} false = 'false'; 
  {normal} this = 'this'; 
  {normal} new = 'new';

  {normal} op = and | lthan | plus | minus | times;

  {normal} comment = '//' [[0..0xffff] - [10 + 13]] * line_terminator;

  {normal->comentado,comentado} comment_start = '/*';
  {comentado} comment_body = [any_character -['*' + '/']]*; 
  {comentado} star = '*'; 
  {comentado} slash = '/';
  {comentado->normal} comment_end = '*/';

  {normal} id = (less_char | more_char)(decimal | less_char | more_char | underscore)*;

  {normal} num = decimal+;

  {normal} blank = (' ' | cr | lf | tab)+;


Ignored Tokens

  blank,comment,comment_start,comment_body,comment_end,star,slash;


Productions

  program = mainclass classdecl*;
  
  mainclass = classe [left]:id [chave1]:lbra public static void main lpar string lcol rcol [right]:id rpar [chave2]:lbra stm [chave3]:rbra [chave4]:rbra;

  classdecl = {normal} classe id [c1]:lbra vardecl* methoddecl* [c2]:rbra |
              {extend} classe [filho]:id extends [pai]:id [c3]:lbra vardecl* methoddecl* [c4]:rbra;
  vardecl = type id semic;

  methoddecl = public type id lpar formallist rpar lbra vardecl* stm* return exp semic rbra;

  formallist = {flist}type id formalrest* |
               {empty} ;

  formalrest = comma type id;

  type = {array} [vetor]:int lcol rcol |
         {bool} boolean |
         {ints} int |
         {others} id;

  stm = {programa} lbra stm* rbra |
        {ifthenelse} if lpar exp rpar [true_stm]:stm else [false_stm]:stm |
        {loops} while [par1]:lpar [exp1]:exp [par2]:rpar [while_stm]:stm |
        {prints} print [par3]:lpar [print_exp]:exp [par4]:rpar semic |
        {assign} id equal [assign_exp]:exp [sc1]:semic |
        {assign_vetor} [id1]:id lcol [vet_exp]:exp rcol [eq]:equal [assing_exp1]:exp [sc2]:semic ;


  exp = {binop} exp2 op exp |
        {exps} exp2 lcol exp rcol |
        {tam}  exp2 dot length |
        {list} exp2 [d1]:dot id lpar explist rpar;
  exp2 = {numero} num |
         {trueexp} true |
         {falseexp} false |
         {idexp} [id_exp]:id |
         {thisexp} this |
         {newint} new int [col1]:lcol [int_exp]:exp [col2]:rcol |
         {newid} [novo]:new [new_id]:id [par1]:lpar [par2]:rpar |
         {notexp} not [not_exp]:exp |
         {parexp} [par3]:lpar [par_exp]:exp [par4]:rpar ;


  explist = {elist}exp exprest* |
            {empty} ;

  exprest = comma exp;

